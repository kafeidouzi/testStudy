##    栈： 先进后出
## 单调栈：指栈中元素必须按照升序或者降序排列的栈

解题思路： 分析 ，画图， 代码 ，扩展， 总结

###                                                 --->  内容一样  ---> 数组push/pop(优化  使用计数器)
### 适用题型：配对或消除  ---> 使用栈思想       |
###                                                 --->  内容不一样  ---> 存放内容
###                                                     （存放本身、存放索引）
###                                                     弹栈（只弹一个、while谈到满足条件位置）

题1： 单一括号配对，eg：'()()((()))',给出一个方法判断左右是否配对

题2： 多种括号配对 ， eg: '{}()[]'

题3： 两个数组，一个存放鱼的大小，一个存放鱼的方向 （0左，右1），两鱼对游，小的被吃。

题4： 给出一个整数数组A，找出每个元素右边第一个比自己小的整数的下标，没找到返回-1

扩展： 题5： 数组中右边第一个比我大的元素位置  / 数组中左边离我最近比我小的元素的位置 /  数组中左边离我最近比我大的元素的位置

题 5： 给定一个正整数数组和k，要求依次取出k个数，要求取出个数的k个数字典序最小

题5： 给定一个数组，该数组元素为木板高度，请求出相邻木板能剪出的最大矩形面积



### 树的深度优先遍历和广度有心遍历实现

```
//广度优先遍历
function wideFun (tree) {
    let vals = []
    let nodes = []
    nodes.push(tree)
    for (let i = 0; i<nodes.length; i++) {
      vals.push(nodes[i].val)
      let n = nodes[i]
      for(let j = 0;j<n.children.length;j++) {
        nodes.push(n.children[j])
      }
    }
    return vals
}

// 深度优先遍历 （尾部出栈，逆向遍历）
function deepFun (tree) {
  let vals = []
  let nodes = []
  nodes.push(tree)
  while(nodes.length != 0 ) {
    let n = nodes.pop()
    vals.push(n.val)
    if(n.children.length > 0) {
      for(let j = n.children-1;j>=0;j--) {
        nodes.push(n.children[j])
      }
    }
  }
}
function deepTraversal(node){
    let nodes=[];
    if(node!=null){
        nodes.push[node];
        let childrens=node.children;
        for(let i=0;i<childrens.length;i++)
            deepTraversal(childrens[i]);
    }
    return nodes;
}
```
### 链表转反链表
```
function nodeList () {

}
function rescallist (list) {
  if(list.length == 0) return;
  let prev = null 
  let curr = list

  while (curr.next != null) {
    let cnext = curr.next
    curr.next = prve == null ? null: prve
    prve = curr
    curr = cnext
  }
  return prev
}
```
### 版本号数组排序
    ```
    let a = ['4.1', '4.8.0','4.7.1', '4.8', '4.10', '5','4.12'] 
    a.sort((a, b) => {
    let i = 0;
    const arr1 = a.split('.');
    const arr2 = b.split('.');
    while (true) {
        const s1 = arr1[i];
        const s2 = arr2[i++];
        if(s1 === undefined ) return -1;
        if(s2 === undefined ) return 1;
        if (s1 === s2) continue;
        return s1 - s2;
    }
});
    ```
### 介绍选择排序和冒泡排序，冒泡排序如何优化
  1. 冒泡排序：依次比较相邻两个元素，然后进行置换位置。没有交换说明已经排序完成
  ```
  function bubbleSort(arr) {
    //let flag ;
    for(var i = 0;i<arr.length;i++) {
        flag = false
      for(var j = i,j<arr.length-i-1;j++) {
        if(arr[j] > arr[j+1]) {
          var temp = arr[j]
          arr[j] = arr[j+1]
          arr[j+1] = temp
          //flag = true
        }
      }
      //if(!flag) {
      //    return ;
      //}
    }
    return arr
  }
  ```
  2. 选择排序：找数组中最小的数，跟外循环对应下标的元素进行换位
  ```
  function selectSort(arr) {
    for(var i = 0;i< arr.length - 1;i++) {
      var minIndex = i
      for(var j = i+1;j<arr.length;j++) {
        if(arr[j] < arr[minIndex]) {
          minIndex = j
        }
      }
      var temp = arr[i]
      arr[i] = arr[minIndex]
      arr[minIndex] = temp
    }
    return arr
  }
  ```
  3. 冒泡优化，可以根据不交换为条件，外层加个flag标志，不交换时直接跳出循环即可
  4. 插入排序 (O(nlogn))
  ```
  function chaRuSort(arr) {
    for(var i=1;i< arr.length;i++) {
      var key = arr[i]
      var j = i - 1
      while( arr[j] > key ) {
        arr[j+1] = arr[j]
        j--;
      }
      arr[j] = key
    }
    return arr
  }
  ```

  var a = {
      value:0,
      valueOf(){
          return this.value +=1
      },
      toString() {
           return this.value +=1
      }
  }